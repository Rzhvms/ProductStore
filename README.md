# Интернет-магазин продуктов питания. Техническая документация проекта


## Обзор системы

Проект представляет собой веб-приложение интернет-магазина продуктов питания. Архитектура монолитная, контейнеризация и оркестрация реализованы через Docker Compose. Система включает API-сервис на .NET, фронтенд на Vue.js, реляционную базу данных PostgreSQL, кэширующий Redis и объектное хранилище MinIO. Компоненты разворачиваются в изолированных контейнерах и взаимодействуют между собой по заданным сетевым правилам.

## Развертывание и запуск

### Требования:
- Установленный [Docker Desktop](https://www.docker.com/products/docker-desktop/)

### Инструкция по запуску:

1. Клонируйте репозиторий:

```cmd
git clone git@github.com:Rzhvms/ProductStore.git
```

2. В корневой директории проекта используется docker-compose.yml. Для запуска выполните команду:
 
``` bash
docker-compose up -d
```
3. После успешного запуска сервисы будут доступны:

- Клиентское приложение: http://localhost:80
- API: http://localhost:8080
- Swagger для просмотра запросов REST-API: http://localhost:8080/swagger/index.html
- База данных PostgreSQL: localhost:5433
- Redis: localhost:6379
- MinIO: localhost:9000 / localhost:9001

## Конфигурация Docker Compose

Система развертывается через Docker Compose и включает четыре основных сервиса. PostgreSQL версии 16 используется как основная реляционная база данных для хранения структурированных данных. Redis 7 версии используется для корзины товаров. API-сервис, построенный на .NET, предоставляет RESTful интерфейс для взаимодействия с бизнес-логикой. Веб-интерфейс, размещенный в отдельном контейнере, обеспечивает пользовательское взаимодействие с системой.

Пример конфигурации Docker Compose:

``` yaml
services:
  postgres:
    image: postgres:16
    container_name: postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - "${POSTGRES_PORT_EXTERNAL}:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7
    container_name: redis
    ports:
      - "${REDIS_PORT_EXTERNAL}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    ports:
      - "${MINIO_PORT_EXTERNAL}:9000"
      - "${MINIO_CONSOLE_PORT_EXTERNAL}:9001"
    volumes:
      - minio-data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 10s
      timeout: 5s
      retries: 5
  minio-init:
    image: minio/mc:latest
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD} &&
      mc mb --ignore-existing myminio/${MINIO_BUCKET} &&
      mc anonymous set download myminio/${MINIO_BUCKET}
      "

  api:
    build:
      context: ./api/ServiceApi
      dockerfile: Api/Dockerfile
    container_name: api
    ports:
      - "${API_PORT_EXTERNAL}:8080"
    environment:
      ASPNETCORE_URLS: http://+:8080
      ConnectionStrings__DefaultConnection: Host=postgres;Port=5432;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}
      Redis__ConnectionString: redis:6379

      Minio__Endpoint: ${MINIO_ENDPOINT}
      Minio__AccessKey: ${MINIO_ROOT_USER}
      Minio__SecretKey: ${MINIO_ROOT_PASSWORD}
      Minio__Bucket: ${MINIO_BUCKET}
    restart: on-failure
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
      minio:
        condition: service_healthy

  web:
    build:
      context: ./front/front-food-shop
      dockerfile: Dockerfile
      network: host
    container_name: web
    ports:
      - "${WEB_PORT_EXTERNAL}:80"
    depends_on:
      - api

volumes:
  pgdata:
  minio-data:

```
Файл .env содержит значения переменных окружения: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB, POSTGRES_PORT_EXTERNAL, REDIS_PORT_EXTERNAL, API_PORT_EXTERNAL, WEB_PORT_EXTERNAL, MINIO_ENDPOINT, MINIO_ROOT_USER, MINIO_ROOT_PASSWORD, MINIO_BUCKET .

## Конфигурация приложения

Конфигурация приложения хранится в /api/ServiceApi/Api/appsettings.json. Ключевые секции включают настройки логирования, JWT, соединение с БД, Redis, внешний адрес приложения, настройки MinIO и ключи внешних API.

Примеры конфигурационных параметров:

``` json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5433;Database=ProductStore;Username=***;Password=***"
  },
  "Redis": {
    "ConnectionString": "redis:6379"
  },
  "App": {
    "PublicBaseUrl": "http://localhost:8080"
  },
  "Minio": {
    "Endpoint": "http://localhost:9000",
    "AccessKey": "minioadmin",
    "SecretKey": "minioadmin123",
    "Bucket": "products",
    "PublicUrl": "http://localhost:9000/products"
  }
}
```

Все конфигурационные параметры безопасности, включая JWT ключи и SMTP пароли, должны быть защищены и заменены в производственном окружении. Секретные ключи и пароли в конфигурации должны быть заменены на реальные значения и храниться в защищенном хранилище секретов при развертывании в продакшн.

## Аутентификация и авторизация

Система использует JWT-токены для аутентификации и авторизации пользователей. Access токены имеют время жизни 3600 секунд и подписываются асимметричной парой RSA ключей. Refresh токены генерируются длиной 64 символа с временем жизни 20000 минут. Все защищенные эндпоинты требуют заголовок Authorization: Bearer {token}.

Пароли хранятся в виде хешей с солью. Публичные и приватные ключи RSA должны храниться отдельно от репозитория и не включаться в опубликованные конфигурации. В производственном окружении текущие ключи должны быть заменены на собственные сгенерированные значения.

## Авторизация для админ-панели

В системе с помощью миграции создается дефолтный пользователь - администратор для доступа к админ-панели.

Данный пользователь имеет следующие параметры:
``` 
Логин (почта): admin@admin.admin
Пароль: defaultAdmin123
```

Разграничение обычного пользователя и администратора происходит по следующему принципу:

В базе данных в таблице ClaimModel имеются колонки Type и Value. 

Пользователь считается администратором, если у него имеется запись с Type = role, Value = admin. Обычный пользователь имеет значение Value = user.

При авторизации со стороны клиентской части приложения (frontend) происходит проверка прав пользователя, в зависимости от которых происходит редирект - либо на админ-панель, либо на главную страницу интернет магазина.

## Конфигурация электронной почты

Для отправки системных уведомлений настроен SMTP-клиент с использованием сервиса Yandex. Конфигурация включает SSL-шифрование соединения на порту 465, аутентификацию через логин и пароль приложения. В продакшне необходимо использовать учетные данные приложения и хранить пароль в защищенном месте. Адрес отправителя и отображаемое имя настраиваются отдельно.

## Интеграция с внешними сервисами

Система интегрирована с Yandex Suggest API для предоставления подсказок при вводе адресов, используя предоставленный API ключ. Для хранения файлов продуктов реализована интеграция с MinIO — S3-совместимым объектным хранилищем. Все ключи и эндпоинты конфигурируются в appsettings.json и переменных окружения.

# REST API интерфейс

Полная документация api-интерфейса расположена в директории api/api-documentation.json

## Обзор API интерфейса

Система предоставляет RESTful API с поддержкой OpenAPI спецификации версии 3.0.1. API организован по функциональным доменам и включает модули для аутентификации, управления пользователями, продуктами, категориями, корзиной, заказами, отзывами, избранным, платежами и подсказками адресов. Все запросы к защищенным эндпоинтам требуют JWT токена в заголовке Authorization по схеме Bearer. API поддерживает формат JSON для обмена данными и возвращает соответствующие HTTP статус-коды для индикации успеха или ошибок. 

Серверное приложение построено по архитектуре DDD и легко поддается масштабированию. Весь C# код в проекте закомментирован. 

## Модуль аутентификации

### Регистрация и верификация пользователей

Эндпоинт /api/auth/register POST позволяет создать нового пользователя, принимая email, пароль и набор claims. После регистрации система отправляет на указанный email PIN-код для подтверждения адреса электронной почты. Верификация осуществляется через эндпоинт /api/auth/verify-email POST, куда передается email и полученный PIN-код. Для продолжения регистрации с заполнением дополнительных данных (имя, фамилия, телефон, дата рождения, пол) используется PATCH запрос на тот же эндпоинт /api/auth/register.

### Авторизация и управление сессиями

Авторизация происходит через эндпоинт /api/auth/login POST с передачей email и пароля. Успешная аутентификация возвращает пару токенов: access token с временем жизни 3600 секунд и refresh token с временем жизни 20000 минут. Обновление токенов осуществляется через /api/auth/refresh-token POST с передачей текущего access и refresh токенов. Выход из системы выполняется через /api/auth/sign-out POST, что инвалидирует текущую сессию пользователя.

### Восстановление доступа и управление паролями

Для сброса пароля используется двухэтапный процесс. Первый этап инициируется через эндпоинт /api/auth/resend-code POST с указанием email, на который отправляется PIN-код для подтверждения операции. Второй этап выполняется через /api/auth/confirm-operation POST с передачей email и PIN-кода, после чего система позволяет установить новый пароль через /api/auth/change-password POST. Аутентифицированные пользователи могут изменить свой пароль через /api/user/me/password PATCH, указав старый и новый пароль.

## Модуль управления продуктами

### Административное управление продуктами

Административные эндпоинты для управления продуктами находятся под префиксом /api/admin-product. Создание продукта выполняется через POST запрос на /api/admin-product/create с передачей названия, описания, цены, количества, идентификатора категории, опционального идентификатора поставщика и характеристик в формате JSON. Получение детальной информации о продукте осуществляется через GET запрос на /api/admin-product/{id}, где id - UUID идентификатор продукта.

Обновление продукта выполняется через PUT запрос на /api/admin-product/{id} с передачей обновленных полей. Удаление продукта - через DELETE запрос на тот же эндпоинт. Пагинированный список всех продуктов доступен через GET запрос на /api/admin-product/list с опциональными параметрами pageNumber и pageSize. Список продуктов по категории доступен через GET запрос на /api/admin-product/{categoryId}/list с аналогичными параметрами пагинации.

### Публичный доступ к продуктам

Публичные эндпоинты для клиентов находятся под префиксом /api/product. Получение информации о конкретном продукте выполняется через GET запрос на /api/product/{id}. Пагинированный список всех продуктов доступен через GET запрос на /api/product/list. Список продуктов по категории доступен через GET запрос на /api/product/{categoryId}/list. Все публичные эндпоинты возвращают только активные продукты, доступные для покупки.

### Управление избранными продуктами

Пользователи могут добавлять продукты в избранное через POST запрос на /api/favorite-products/{productId} и удалять через DELETE запрос на тот же эндпоинт. Просмотр списка избранных продуктов выполняется через GET запрос на /api/favorite-products/list с поддержкой пагинации. Массовое удаление избранных продуктов осуществляется через POST запрос на /api/favorite-products/delete-list с передачей массива идентификаторов продуктов.

## Модуль управления категориями

Создание категории выполняется через POST запрос на /api/categories/create с передачей названия и опционального идентификатора родительской категории. Получение информации о категории - через GET запрос на /api/categories/{id}. Обновление категории - через PUT запрос на тот же эндпоинт с передачей нового названия и опционального родительского идентификатора. Удаление категории - через DELETE запрос.

Полный список всех категорий доступен через GET запрос на /api/categories/list без параметров пагинации, возвращая плоский список всех категорий в системе. Категории поддерживают иерархическую структуру через поле parentId, что позволяет создавать древовидные каталоги продуктов.

## Модуль управления корзиной

### Работа с элементами корзины

Получение текущей корзины пользователя выполняется через GET запрос на /api/cart, который возвращает список продуктов с количеством, ценой и общей стоимостью. Добавление или обновление элемента корзины осуществляется через POST запрос на /api/cart/items с передачей идентификатора продукта и количества. Если продукт уже присутствует в корзине, его количество обновляется.

Удаление конкретного продукта из корзины выполняется через DELETE запрос на /api/cart/items/{productId}. Полная очистка корзины осуществляется через DELETE запрос на /api/cart. После успешной оплаты заказа корзина может быть автоматически очищена через устаревший эндпоинт /api/cart/clear-after-payment POST с передачей идентификаторов пользователя и платежа.

## Модуль управления заказами

### Создание и получение заказов

Создание нового заказа выполняется через POST запрос на /api/orders без дополнительных параметров, так как заказ формируется на основе текущей корзины пользователя. Система возвращает идентификатор созданного заказа и URL для оплаты. Получение информации о конкретном заказе осуществляется через GET запрос на /api/orders/{id}.

Пагинированный список заказов пользователя доступен через GET запрос на /api/orders/list с параметрами pageNumber и pageSize. Администраторы могут изменять статус заказа через PATCH запрос на /api/orders/{id} с передачей нового статуса из перечисления OrderStateEnum, которое включает состояния от создания до доставки и отмены.

## Модуль управления отзывами

### Создание и управление отзывами

Добавление отзыва к продукту выполняется через POST запрос на /api/review с передачей идентификатора продукта, рейтинга от 1 до 5 и опционального текстового сообщения до 300 символов. Получение конкретного отзыва осуществляется через GET запрос на /api/review/{reviewId}. Список отзывов для продукта доступен через GET запрос на /api/review/{productId}/list.

Пользователи могут редактировать свои отзывы через PATCH запрос на /api/review/patch-review/{reviewId} с передачей обновленного рейтинга и/или сообщения. Удаление отзыва выполняется через DELETE запрос на /api/review/{reviewId}. Администраторы могут управлять видимостью отзывов через PATCH запрос на /api/review/admin/change-visible/{reviewId} с передачей флага isVisible.

## Модуль управления пользователями

### Профиль пользователя

Получение базовой информации о текущем пользователе выполняется через GET запрос на /api/user/me, который возвращает email, телефон, имя, фамилию и даты создания/обновления. Обновление этой информации осуществляется через PATCH запрос на тот же эндпоинт с передачей обновляемых полей. Полное удаление аккаунта пользователя выполняется через DELETE запрос на /api/user.

Расширенный профиль пользователя, включая дату рождения, пол и дополнительную информацию, доступен через GET запрос на /api/user/profile. Обновление расширенного профиля выполняется через PATCH запрос на тот же эндпоинт. Изменение пароля аутентифицированным пользователем осуществляется через PATCH запрос на /api/user/me/password с передачей старого и нового пароля.

### Адреса пользователя

Получение адреса пользователя выполняется через GET запрос на /api/user/address. Добавление нового адреса осуществляется через POST запрос с передачей деталей адреса, включая страну, регион, город, улицу, дом, квартиру, почтовый индекс, этаж, подъезд и флаг адреса по умолчанию. Обновление существующего адреса - через PATCH запрос. Удаление адреса - через DELETE запрос.

### Административное управление пользователями

Административные эндпоинты для управления пользователями находятся под префиксом /api/admin/user-info. Администраторы могут получать и обновлять базовую информацию любого пользователя через GET и PATCH запросы на /api/admin/user-info/base с параметром id. Изменение пароля пользователя администратором осуществляется через PATCH запрос на /api/admin/user-info/base/password.

Расширенный профиль пользователя доступен администраторам через GET запрос на /api/admin/user-info/profile с параметром userId. Обновление профиля - через PATCH запрос на тот же эндпоинт. Управление адресами пользователей администраторами осуществляется через аналогичные эндпоинты под префиксом /api/admin/user-info/address с параметром userId.

## Модуль платежей

### Моковые платежи

Система включает моковый модуль платежей для тестирования, по своей сути являющейся симулятором. Информация о платеже доступна через GET запрос на /api/mock-payments/{paymentId}. Подтверждение платежа выполняется через POST запрос на /api/mock-payments/{paymentId}/pay. Отмена платежа - через POST запрос на /api/mock-payments/{paymentId}/cancel. Модель платежа включает идентификатор, сумму, валюту, метод оплаты, статус и ссылку для оплаты.

## Интеграция с внешними сервисами

### Подсказки адресов через Yandex Maps

Система интегрирована с Yandex Suggest API для предоставления подсказок при вводе адресов. Эндпоинт /api/suggest-address GET принимает параметр queryParams - строку поиска адреса, и возвращает список предложений с идентификатором, заголовком и подзаголовком. Интеграция использует API ключ, указанный в конфигурации, и предназначена для улучшения пользовательского опыта при заполнении адресных данных.

## Модели данных и схемы

### Общие структуры данных

Система использует строго типизированные модели данных для всех запросов и ответов. Все идентификаторы представлены в формате UUID. Модели включают валидационные правила, такие как минимальная и максимальная длина строк, диапазоны числовых значений, обязательные поля. Для сложных структур, таких как характеристики продуктов, используется тип JsonNode, позволяющий хранить произвольные JSON данные.

Все сущности используют UUID в качестве первичных ключей. Денежные поля используют точные числовые типы (decimal) для финансовой корректности. Дата и время сериализуются в формате ISO-8601.

### Основные модели данных

OrderModel хранит заказ с ссылкой на пользователя, статусом из OrderStateEnum, суммой и датой создания.

OrderProductModel реализует связь заказов и продуктов с указанием количества каждого товара.

ProductModel содержит название, описание, цену, количество на складе и поле characteristics в формате JSONB для гибких атрибутов.

ProductReviewModel содержит рейтинг (1–5), текст и флаг видимости isVisible.

PaymentModel хранит платежи с суммой, валютой, методом оплаты, статусом, ссылкой на оплату и информацией о возврате.

UserModel содержит учетные данные, ClaimModel хранит утверждения пользователя, RefreshTokenModel управляет refresh токенами.

UserProfileModel и UserAddressModel содержат расширенные данные профиля и адреса.

FavoriteProductsModel реализует связь многие-ко-многим между пользователем и продуктом.

ImageModel хранит URL изображений, а также основное ли это изображение товара.

## Перечисления и статусы

OrderStateEnum определяет возможные состояния заказа:

```
namespace Domain.Order;

/// <summary>
/// Перечисление состояний заказа
/// </summary>
public enum OrderStateEnum
{
    /// <summary>
    /// Заказ создан
    /// </summary>
    Created = 0,
    
    /// <summary>
    /// Заказ подтвержден
    /// </summary>
    Confirmed = 1,
    
    /// <summary>
    /// На сборке
    /// </summary>
    Assembling = 2,
    
    /// <summary>
    /// Собран
    /// </summary>
    Assembled = 3,
    
    /// <summary>
    /// Ожидает курьера
    /// </summary>
    AwaitingCourier = 4,
    
    /// <summary>
    /// Передан курьеру
    /// </summary>
    HandedToCourier = 5,
    
    /// <summary>
    /// В пути
    /// </summary>
    OnTheWay = 6,
    
    /// <summary>
    /// Доставлен
    /// </summary>
    Delivered = 7,
    
    /// <summary>
    /// Отменен
    /// </summary>
    Cancelled = 8,
    
    /// <summary>
    /// Иное, для возможного расширения
    /// </summary>
    Default = 9
}
```

PaymentMethodEnum определяет методы оплаты: 

```
namespace Domain.Payment;

/// <summary>
/// Способы оплаты
/// </summary>
public enum PaymentMethodEnum
{
    /// <summary>
    /// Банковская карта
    /// </summary>
    Card = 1,
    
    /// <summary>
    /// СБП
    /// </summary>
    Sbp = 2,
    
    /// <summary>
    /// Наличные
    /// </summary>
    Cash = 3,
    
    /// <summary>
    /// Перевод
    /// </summary>
    BankTransfer = 4,
    
    /// <summary>
    /// ApplePay
    /// </summary>
    ApplePay = 5,
    
    /// <summary>
    /// GooglePay
    /// </summary>
    GooglePay = 6
}
```

PaymentStatusEnum определяет статусы платежей:

```
namespace Domain.Payment;

/// <summary>
/// Статус оплаты
/// </summary>
public enum PaymentStatusEnum
{
    /// <summary>
    /// Платеж создан, но не оплачен
    /// </summary>
    Pending = 1,
    
    /// <summary>
    /// Деньги зарезервированы
    /// </summary>
    WaitingForCapture = 2,
    
    /// <summary>
    /// Платеж полностью оплачен
    /// </summary>
    Paid = 3,
    
    /// <summary>
    /// Ошибка оплаты
    /// </summary>
    Failed = 4,
    
    /// <summary>
    /// Платёж отменён
    /// </summary>
    Canceled = 5,
    
    /// <summary>
    /// Деньги возвращены
    /// </summary>
    Refunded = 6 
}
```

## Обработка ошибок
Система возвращает стандартизированные ответы об ошибках в формате ProblemDetails, включая тип ошибки, заголовок, HTTP статус, детальное описание и экземпляр. Для ошибок валидации возвращаются соответствующие HTTP статус-коды с деталями нарушения бизнес-правил. Все ошибки аутентификации и авторизации возвращают соответствующие HTTP статус-коды без раскрытия внутренней информации о системе.

В случае возникновения 500-ошибок реализованы кастомизированные ошибки, а также обработчик, подменяющий ошибку на 400 Bad Request.

```
namespace Application.Exceptions.Base;

/// <summary>
/// Класс кастомной ошибки
/// </summary>
public class BaseException : Exception
{
    protected BaseException(string message) : base(message) { }
    protected BaseException(string message, Exception inner) : base(message, inner) { }
}
```

## Безопасность API
Все защищенные эндпоинты требуют валидного JWT токена в заголовке Authorization по схеме Bearer. Токены подписываются асимметричными RSA ключами, что обеспечивает безопасность и возможность верификации без доступа к приватному ключу. Refresh токены имеют временя жизни 20000 минут и могут быть использованы для получения новой пары токенов. Все пароли хешируются с солью перед сохранением в базу данных.

## Пагинация и фильтрация
Эндпоинты, возвращающие списки, поддерживают пагинацию через параметры pageNumber и pageSize. Значения по умолчанию устанавливаются на клиенте. Фильтрация по категориям поддерживается через эндпоинты с параметром categoryId в пути. Все параметры запросов валидируются на стороне сервера с возвратом соответствующих ошибок при некорректных значениях.

# База данных и миграции

## Архитектура базы данных

Система использует реляционную базу данных PostgreSQL 16 версии для хранения структурированных данных. Архитектура базы данных следует принципам нормализации и включает четкое разделение на доменные модели, соответствующие бизнес-сущностям системы. Все таблицы используют идентификаторы в формате UUID в качестве первичных ключей, что обеспечивает глобальную уникальность и безопасность данных.

## Система управления миграциями

Для управления миграциями базы данных используется библиотека FluentMigrator, которая предоставляет декларативный подход к определению изменений структуры данных. Миграции организованы в хронологическом порядке с использованием временных меток в названиях, что обеспечивает последовательное применение изменений. Каждая миграция содержит методы Up для применения изменений и Down для их отката, поддерживая принцип обратимости.

## Структура таблиц

### Модель пользователей

Таблица UserModel является центральной сущностью системы аутентификации и авторизации. Она содержит базовые данные пользователя: уникальный email с индексом для быстрого поиска, телефон, хешированный пароль с солью для обеспечения безопасности, имя и фамилию, даты создания и обновления записи, а также флаг подтверждения email. Все строковые поля имеют ограничения по длине для оптимизации хранения.

Связанные таблицы ClaimModel и RefreshTokenModel обеспечивают систему claims-based авторизации и управление сессиями. Таблица ClaimModel хранит дополнительные утверждения пользователя, связанные внешним ключом с UserModel. Таблица RefreshTokenModel содержит refresh токены с указанием срока действия и статуса активности, также связанные с пользователем.

### Расширенный профиль пользователя

Таблица UserProfileModel хранит дополнительные данные профиля пользователя, включая URL аватара (не используется), дату рождения, пол и произвольную информацию о пользователе. Связь с UserModel осуществляется через уникальный внешний ключ UserId, обеспечивая отношение один к одному.

Таблица UserAddressModel содержит адресные данных пользователей с поддержкой иерархической структуры: страна, регион, город, улица, дом, квартира, почтовый индекс. Дополнительные поля floor и entrance были добавлены в более поздней миграции для уточнения адресной информации. Поле isDefault определяет адрес по умолчанию для пользователя.

### Каталог продуктов

Таблица CategoryModel реализует иерархическую структуру категорий продуктов через рекурсивную связь ParentId. Это позволяет создавать древовидные каталоги любой глубины. Каждая категория имеет уникальное название и может быть связана с родительской категорией через внешний ключ.

Таблица ProductModel содержит основные данные о продуктах: название, описание, цену, количество на складе, характеристики в формате JSONB. Связь с категориями осуществляется через поле CategoryId, а с поставщиками - через поле ProviderId. Составной индекс по полям Id и CategoryId оптимизирует запросы фильтрации продуктов по категориям.

### Изображения и отзывы продуктов

Таблица ImageModel хранит ссылки на изображения продуктов с поддержкой порядка отображения через поле SortOrder. Каждое изображение связано с продуктом через внешний ключ ProductId.

Таблица ProductReviewModel содержит отзывы пользователей о продуктах с оценкой от 1 до 5, текстовым сообщением до 300 символов, датой создания и флагом видимости isVisible. Связи с UserModel и ProductModel обеспечивают целостность данных и возможность фильтрации отзывов по пользователю или продукту.

### Система заказов и доставки

Таблица OrderModel хранит информацию о заказах: идентификатор заказчика, статус заказа из перечисления OrderStateEnum, идентификатор доставки, общую сумму и дату создания. Внешние ключи связывают заказ с пользователем и доставкой.

Таблица OrderProductModel реализует связь многие-ко-многим между заказами и продуктами, храня количество каждого продукта в заказе. Эта структура позволяет одному заказу содержать несколько продуктов с разными количествами.

Таблица DeliveryModel содержит информацию о доставке: дату доставки, адрес и стоимость. Отдельное хранение данных доставки позволяет изменять параметры доставки независимо от заказа. В данной версии приложения не используется.

### Платежная система

Таблица PaymentModel хранит информацию о платежах: сумму, валюту, метод оплаты из перечисления PaymentMethodEnum, статус из PaymentStatusEnum, идентификатор платежной системы, URL для оплаты, флаг возврата средств и сумму возврата. Связи с OrderModel и UserModel обеспечивают отслеживание платежей по заказам и пользователям.

### Поставщики продуктов

Таблица ProviderModel содержит информацию о поставщиках: название, контактный телефон, email и адрес. Связь с продуктами позволяет отслеживать происхождение товаров и управлять цепочками поставок. В данной версии приложения не используется.

### Система избранного

Таблица FavoriteProductsModel реализует функциональность избранных продуктов пользователей через связь многие-ко-многим между UserModel и ProductModel. Каждая запись содержит идентификатор пользователя и идентификатор продукта, что позволяет пользователям добавлять продукты в избранное для быстрого доступа.

## Стратегия хранения JSON данных

JSON-характеристики товаров сохраняются в поле типа JSONB, что позволяет индексировать и выполнять сложные запросы по атрибутам. Поле characteristics в таблице ProductModel использует тип данных JSONB, который предоставляет баланс между гибкостью NoSQL и мощностью реляционных баз данных. JSONB поддерживает индексацию, сложные запросы и валидацию структуры данных. Этот подход позволяет хранить разнообразные характеристики продуктов без необходимости изменять схему базы данных при добавлении новых атрибутов.

## Индексы и оптимизация

Система использует составные индексы для оптимизации частых запросов. Индекс IX_ProductModel_Id_CategoryId ускоряет фильтрацию продуктов по категориям, что особенно важно для каталога с большим количеством товаров. Уникальный индекс на поле email в таблице UserModel обеспечивает быстрый поиск пользователей по email и предотвращает дублирование адресов.

Поля с частыми условиями поиска, такие как статусы заказов и платежей, также индексируются для улучшения производительности. JSONB тип данных для поля characteristics в таблице ProductModel позволяет хранить структурированные характеристики продуктов с возможностью индексации и сложных запросов.

Индексы настроены для ускорения частых операций: поиск по email, фильтрация продуктов по категории, выборка по статусам заказов и платежей. При необходимости добавляются частичные и include-индексы для повышения производительности агрегирующих и выборочных запросов.

## Внешние ключи и целостность данных

Все таблицы связаны через внешние ключи с каскадным удалением и обновлением, что обеспечивает целостность данных при удалении родительских записей. Например, удаление пользователя приводит к удалению всех связанных записей: адресов, профиля, заказов, платежей и избранных продуктов. Такая конфигурация предотвращает появление "висящих" ссылок в базе данных.

Рекурсивный внешний ключ в таблице CategoryModel обеспечивает целостность иерархической структуры категорий. Уникальные ограничения на поля UserId в таблицах UserProfileModel и UserAddressModel гарантируют, что каждый пользователь имеет не более одного профиля и одного адреса.

Связи между таблицами реализованы через внешние ключи. Важно: при настройке каскадных операций продумать влияние на связанные данные, особенно в продакшн. Уникальные ограничения защищают от дублирования ключевых значений, например, email в таблице пользователей.

## Управление версиями схемы

Нумерация миграций следует формату ГГГГММДДЧЧММ, что обеспечивает хронологический порядок применения. Каждая миграция содержит комментарий с описанием изменений, что упрощает понимание эволюции схемы базы данных. При необходимости изменения существующих миграций создаются новые версии, а не модифицируются существующие, что соответствует принципам неизменяемости инфраструктуры.

## Миграция данных

Процесс миграций построен с учетом безопасности и надежности. Каждая миграция проверяет существование таблиц и столбцов перед выполнением операций, что делает миграции идемпотентными и безопасными для повторного выполнения. Метод Down обеспечивает возможность отката изменений в случае возникновения проблем.

Миграции применяются автоматически при запуске приложения через механизм FluentMigrator, который отслеживает примененные миграции в служебной таблице VersionInfo. Это позволяет синхронизировать схемы баз данных в разных окружениях и обеспечивать последовательность изменений при развертывании.

## Производительность и масштабируемость

Использование UUID в качестве первичных ключей упрощает горизонтальное масштабирование и репликацию данных. Отсутствие автогенерируемых последовательностей предотвращает конфликты при распределенной вставке данных. Индексы на часто используемых полях оптимизируют производительность запросов, особенно важных для пользовательского интерфейса, таких как фильтрация продуктов и поиск пользователей.

Типы данных выбраны с учетом требований к точности и производительности. Десятичные типы для цен обеспечивают точность финансовых расчетов, целочисленные типы для количеств оптимизируют хранение и операции. Ограничения длины строковых полей предотвращают неконтролируемый рост базы данных и улучшают производительность индексов.

Использование UUID упрощает масштабирование и раскатку реплик. Индексация часто используемых полей уменьшает время выборки. JSONB обеспечивает гибкость без необходимости частых изменений схемы. Для повышения пропускной способности возможна горизонтальная масштабировка API-слоя с балансировкой нагрузки, а также настройка репликации PostgreSQL и кластеризации Redis.

## Резервное копирование и восстановление

Структура базы данных совместима со стандартными инструментами резервного копирования PostgreSQL. Docker-контейнер PostgreSQL настроен на хранение данных в именованном томе pgdata, что обеспечивает сохранность данных при перезапуске контейнеров. Для производственного использования рекомендуется настройка регулярных резервных копий и репликации в standby-серверы.

Данные PostgreSQL хранятся в именованном томе. Для производства рекомендована настройка регулярных бэкапов, WAL-архивации и репликации. Миграции спроектированы таким образом, чтобы быть совместимыми с процессами резервного копирования и восстановления. Откат миграций через метод Down позволяет восстановить предыдущее состояние схемы в случае необходимости, хотя в производственной среде рекомендуется использовать стратегию только вперед с созданием новых миграций для исправления проблем.

## Логирование и мониторинг

Логирование настроено через стандартные механизмы .NET. Уровни логирования конфигурируются в appsettings.json. Рекомендуется интегрировать централизованный стек логирования и мониторинга (Prometheus/Grafana, ELK или аналог) для сбора метрик и логов в продакшне.
